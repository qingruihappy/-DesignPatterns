package com.DesignPatterns.al.Dynamic3;
/**
 * 现在假如我们有一个打印日志的代理，一个打印时间的代理（甚至还有事物的代理，还比如说我检查当前的人有没有运行我这个方法的权限等等）。
 * 假如我们用继承的话会怎么办呢，我们就的让打印日志的代理继承目标，再让打印时间的代理继承时间的类，让事物的代理继承代理时间的类，让运行权限的代理继承事物的代理......
 *。还有就是假如现在我们换了顺序了，先出打印日志的代理，然后在用时间的代理继承时间的代理，那么又会多出来两个代理类，想想都是一件恐怖的事情，类太多了。
 *
 * 但是我们用接口（聚合呢，我们来看这个例子。）
 * 聚合有点类似于装饰着设计模式：在这里我们要注意这几模式其实更看重的是使用场景，而不是具体细节的用法。
 * 其实设计模式多多少少都想多态，但是我们注意设计模式更看重的是语义上的而不是语法上的。
 * 
 * 
 * 现在静态的代理已经将完了，但是我们来看这个代理有什么缺陷，首先代理类和目标类必须继承相同的接口（虽然是缺点但是可以接受）
 * 但是还有一个就是，假如现在有其它的类加car也需要实现打印时间的代理，那我们怎么做的，你说好说，在写一个car的代理呗。
 * 那假如现在有自行车，火车，货车，电瓶车，小推车，等等100多个都要求实现时间的代理，是不是需要些100多个类呢。
 * 
 * 下面就引出了动态代理。
 * @author qingruihappy
 * @data   2018年11月1日 上午12:39:35
 * @说明:
 */
public class Test {
	public static void main(String[] args) {
	/*	TankTime m=new TankTime(new Tank());
		TankLog n=new TankLog(m);
		n.move();*/
		
		TankLog m=new TankLog(new Tank());
		TankTime n=new TankTime(m);
		n.move();
	}

}

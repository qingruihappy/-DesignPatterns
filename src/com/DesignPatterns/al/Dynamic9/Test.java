package com.DesignPatterns.al.Dynamic9;

/**
 * 
 * @author qingruihappy
 * @data 2018年11月1日 上午12:39:35
 * @说明:现在模拟配置类随意切换的问题
 * 
 * 现在可以对任意的对象，任意的接口方法，实现任意的代理
 *现在我们写的差不多了，我们来捋一下思路
 *1，我们首先要知道动态代理要干啥呢？
 *动态代理就是类似于面向切面编程，我们在不知不觉中间就把类似于日志，事物，权限，加解密等非业务代码逻辑加到了目标函数的前后。
 *2，我们来看一下，我们平常遇到的jdk动态代理是怎么用的。
 *2.1，写出目标（业务）函数，并且必须让它实现一个接口，
 *2.2，写出非业务代码的接口，并且让子类来实现非业务代码
 *2.3，在非业务代码中又通过发射来调用业务代码，（注意这里面无非就是目标类.目标方法，反射特有的invoke方法）
 *2.4,通过（Proxy）动态的获取变化的代理类
 *3，动态的获取变化的代理才是动态代理的难点，因为，生成代理类的proxy是封装过得，而生成的代理的java代码我们也是看不到的
 *这个也就是难点
 *3.1，至于如何获取请看下面
 *		// 1,首先把不用变的代码以静态string的形式写入进了动态类中
		// 2,接口：把动态变化的东西比如说接口，通过传入的接口来获取，
		// 3,方法：因为接口中就有了实现类的方法，所以通过接口也能获取，其中的方法，
		// 4,回调：把非业务代码的实现了传入到Proxy中来，当调用第三步已经确定了的方法额时候，就明确的调用在非业务代码中的invoke方法
		//4.1,目标：在非业务代码的中间反射调用业务代码
		// 5,写出：写完了之后生成java文件
		// 6,编译：编译生成class文件
		// 7,内存：加载到内存中来
		// 8,反射：从内从中反射生成对象。（注意这这里传入了tank确定了是tank对象，所以当下面调用）
		//9,对象：获取代理对象
 */
public class Test {
	public static void main(String[] args) throws Exception {
		Tank t = new Tank();
		InvocationHandler h = new TimeHandler(t);
		Moveable m = (Moveable) Proxy.newProxyInstance(Moveable.class, h);
		m.move();
	}

}

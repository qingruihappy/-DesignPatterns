    到现在为止，你绝的怎么样了，简直烂透了，这真是一个超笨的主意，
你没发现这么一来重复的代码会变多吗？如果你认为覆盖几个方法就算是差劲，
那么对于100个Duck的子类都要稍微修改一下飞行的行为，你又怎么说？!难道一个个子类去修改吗？

    我们知道，并非“所有”的子类都具有飞行和呱呱叫的行为，所以继承并不是适当的解决方式。
虽然Flyable与Quackable可以解决“一部分”问题（不会再有会飞的橡皮鸭），但是却造成代码无法复用，
这只能算是从一个恶梦跳进另一个恶梦。甚至，在会飞的鸭子中，飞行的动作可能还有多种变化……

    我们会用老方法找出一个解决之道：“采用良好的OO软件设计原则”。


    如果能有一种建立软件的方法，好让我们可以用一种对既有的代码影响最小的方式来修改软件该有
多好。我们就可以花较少时间重做代码，而多让程序去做更酷的事……

    不变的是变化
      
    软件开发的一个不变真理
    
  change
  
    不管当初软件设计得多好，一段时间之后，总是需要成长与改变，否则软件就会“死亡”。
  
  
    看到这里看到问题了吧，问题有1:代码在多个子类中重复。2:运行时的行为不容易改变。3:改变会牵一发动全身，造成其他鸭子不想要的改变。

    继承可能不是答案，假如以后每六个月更新产品（至于更新的方法，他们还没想到）。
那么规格会常常改变，每当有新的鸭子子类出现，就要被迫检查并可能需要覆盖fly()和quark()……这简直是无穷无尽的噩梦。

    现在突发奇想，我们我可以把fly()从超类中取出来，放进一个“Flyable接口”中。这么一来，
    只有会飞的鸭子才实现此接口。同样的方式，也可以用来设计一个“Quackable接口”，因为不是所有的鸭子都会叫。 请看introduction5